\section{استفاده از تحلیل رفتار اجرایی}
تحلیل رفتار اجرایی، که در ادبیات امنیت سایبری به عنوان تحلیل پویا (\lr{Dynamic Analysis}) نیز شناخته می‌شود، رویکردی است که بر مشاهده عملکرد برنامه در حین اجرا تمرکز دارد. این روش به عنوان پاسخی مستقیم به محدودیت‌های تحلیل ایستا (\lr{Static Analysis}) توسعه یافته است. در حالی که تکنیک‌های ضد دیس‌اسمبلی با دستکاری جریان کنترل (\lr{Control Flow}) و تزریق دستورات انحرافی سعی در گمراه کردن ابزارهای دیس‌اسمبلر و تحلیل‌گرانی دارند که کد را روی دیسک بررسی می‌کنند، تحلیل رفتاری با نادیده گرفتن ساختار داخلی کد و تمرکز بر «نیت» و «اثر» برنامه، این موانع را دور می‌زند. \cite{fiveable2025antireverse} \cite{paloaltonetworks2024static}

\subsection{معماری آزمایشگاه و متدولوژی پایش}
برای انجام یک تحلیل رفتاری دقیق که بتواند لایه‌های ضد تحلیل را خنثی کند، محیط آزمایشگاه باید به گونه‌ای پیکربندی شود که تمامی آثار دیجیتال (\lr{Digital Footprints}) ثبت گردند و در عین حال، بدافزار قادر به تشخیص محیط مجازی نباشد. استفاده از ماشین‌های مجازی ایزوله مانند \lr{Flare VM} (مبتنی بر ویندوز) و \lr{Remnux} (مبتنی بر لینوکس) به عنوان استاندارد صنعتی پذیرفته شده است.  \cite{le2021malware}

فرآیند تحلیل رفتاری معمولاً شامل مراحل زیر است که هر یک لایه‌ای از فعالیت‌های بدافزار را آشکار می‌سازد:

\begin{enumerate}
    \item \textbf{تصویربرداری از وضعیت سیستم (\lr{System State Snapshot}):}
    قبل از اجرای نمونه مشکوک، ضروری است که وضعیت پایه سیستم ثبت شود. ابزارهایی مانند \lr{Regshot} یا \lr{Process Hacker} برای گرفتن تصویر از وضعیت رجیستری و فایل‌سیستم استفاده می‌شوند. پس از اجرای بدافزار و اتمام دوره فعالیت آن، تصویر دوم گرفته شده و با تصویر اول مقایسه می‌شود. این مقایسه تغییرات پایداری (\lr{Persistence Mechanisms}) مانند ایجاد کلیدهای رجیستری برای اجرای خودکار (\lr{Run Keys}) یا تغییرات در تنظیمات امنیتی سیستم را آشکار می‌سازد.    \cite{le2021malware}

    \item \textbf{پایش فعالیت‌های سیستمی (\lr{System Activity Monitoring}):}
    در حین اجرای بدافزار، ابزار \lr{Process Monitor (ProcMon)} نقشی حیاتی ایفا می‌کند. این ابزار تمامی فعالیت‌های فایل‌سیستم، رجیستری و پروسه‌ها را در زمان واقعی ضبط می‌کند. تحلیل‌گران با استفاده از فیلترهای اختصاصی، نویزهای سیستم‌عامل را حذف کرده و تمرکز خود را بر روی پروسه مخرب قرار می‌دهند. برای مثال، مشاهده تلاش‌های مکرر برای دسترسی به فایل‌های خاص یا بارگذاری کتابخانه‌های دینامیک (\lr{DLLs}) مشکوک می‌تواند نشان‌دهنده تلاش برای تزریق کد (\lr{Code Injection}) یا سرقت اطلاعات باشد.    \cite{le2021malware} \cite{fox2025unpack}

    \item \textbf{تحلیل ترافیک شبکه (\lr{Network Traffic Analysis}):}
    بسیاری از بدافزارها برای دریافت دستورات یا ارسال اطلاعات سرقت شده با سرورهای کنترل و فرمان (\lr{C2}) ارتباط برقرار می‌کنند. برای تحلیل این ارتباطات بدون به خطر انداختن شبکه واقعی، از ابزارهایی مانند \lr{Wireshark} برای شنود پکت‌ها و \lr{Fiddler} برای تحلیل ترافیک \lr{HTTP/HTTPS} استفاده می‌شود. در یک محیط آزمایشگاهی پیشرفته، ماشین \lr{Remnux} به عنوان دروازه اینترنت (\lr{Gateway}) برای ماشین \lr{Flare VM} عمل کرده و با ابزارهایی مانند \lr{FakeDNS} و \lr{Inetsim} سرویس‌های اینترنتی را شبیه‌سازی می‌کند. این امر بدافزار را فریب می‌دهد تا درخواست‌های خود را ارسال کند، حتی اگر دسترسی واقعی به اینترنت وجود نداشته باشد.    \cite{le2021malware} \cite{fox2025unpack}
\end{enumerate}

\subsection{چالش‌های ضد دیباگ و راهکارهای عبور (\lr{Anti-Anti-Debugging})}
یکی از چالش‌های اصلی در تحلیل رفتاری، مکانیزم‌های «ضد دیباگ» (\lr{Anti-Debugging}) است. نویسندگان بدافزار کد خود را به گونه‌ای طراحی می‌کنند که محیط تحلیل را شناسایی کرده و در صورت تشخیص دیباگر یا ماشین مجازی، رفتار خود را تغییر داده یا اجرا را متوقف کنند. این تکنیک‌ها تحلیل‌گر را مجبور می‌کنند تا از روش‌های «ضد ضد دیباگ» استفاده کند. \cite{rodgers2025antireverse} \cite{mitre2024cybersecurity}

\subsubsection{تکنیک‌های شناسایی دیباگر}
بدافزارها از روش‌های متنوعی برای کشف حضور دیباگر استفاده می‌کنند:
\begin{description}
    \item[بررسی پرچم‌های سیستم] استفاده از توابع \lr{API} ویندوز مانند \lr{IsDebuggerPresent} یا بررسی مستقیم ساختار \lr{PEB (Process Environment Block)} برای یافتن پرچم‌های \lr{BeingDebugged} و \lr{NtGlobalFlag}. \cite{rodgers2025antireverse} \cite{mitre2024cybersecurity}
    \item[بررسی‌های زمانی (\lr{Timing Checks})] استفاده از دستوراتی مانند \lr{RDTSC} برای اندازه‌گیری تعداد چرخه‌های پردازنده. از آنجا که اجرای کد در دیباگر (به خصوص در حالت \lr{Single-step}) بسیار کندتر از اجرای عادی است، اختلاف زمانی زیاد نشان‌دهنده حضور تحلیل‌گر است. \cite{fiveable2025antireverse} \cite{sikorski2012practical}
    \item[تزریق کد و اسکن وقفه] جستجو برای دستورات وقفه نرم‌افزاری (\lr{INT 3}) که توسط دیباگرها برای ایجاد نقاط توقف (\lr{Breakpoints}) در کد تزریق می‌شوند. \cite{sikorski2012practical}
\end{description}

\subsubsection{راهکارهای مقابله (\lr{Anti-Anti-Debugging})}
در چارچوب «ضد ضد دیس‌اسمبلی»، تحلیل‌گران از استراتژی‌های زیر برای پنهان‌سازی ابزارهای خود و خنثی‌سازی تکنیک‌های شناسایی استفاده می‌کنند:
\begin{enumerate}
    \item \textbf{تحلیل مبتنی بر هایپروایزر (\lr{Hypervisor-based Analysis}):}
    استفاده از ابزارهایی مانند \lr{HyperDbg} یا تکنیک‌های درون‌نگری ماشین مجازی (\lr{VMI}) که خارج از سیستم‌عامل مهمان اجرا می‌شوند، یکی از پیشرفته‌ترین روش‌هاست. در این معماری، ابزار تحلیل در سطح هایپروایزر (Ring -1) قرار دارد و سیستم‌عامل مهمان و بدافزار که در سطح کرنل (Ring 0) یا کاربر (Ring 3) اجرا می‌شوند، قادر به تشخیص یا دستکاری آن نیستند. این روش به تحلیل‌گر اجازه می‌دهد تا بدون تغییر در ساختارهای حافظه سیستم عامل مهمان (که بدافزار آن‌ها را بررسی می‌کند)، بر اجرا نظارت داشته باشد و شفافیت تحلیل را به حداکثر برساند. \cite{ugurlu2009stealth} 

    \item \textbf{پنهان‌سازی مصنوعات (\lr{Artifact Hiding}):}
    برای مقابله با بدافزارهایی که محیط‌های مجازی مانند \lr{VMware} یا \lr{VirtualBox} را شناسایی می‌کنند، تحلیل‌گران باید مصنوعات این محیط‌ها را پنهان کنند. این شامل تغییر نام درایورهای دستگاه، اصلاح جداول \lr{ACPI}، تغییر آدرس‌های \lr{MAC} کارت شبکه و استفاده از پلاگین‌هایی مانند \lr{ScyllaHide} است. پلاگین \lr{ScyllaHide} می‌تواند توابع \lr{API} مربوط به تشخیص دیباگر (مانند \lr{IsDebuggerPresent}) را در حافظه هوک کرده و همواره مقدار "False" را برگرداند، بدین ترتیب بدافزار فریب خورده و به اجرای مخرب خود ادامه می‌دهد. \cite{mitre2024cybersecurity} \cite{ugurlu2009stealth}

    \item \textbf{دستکاری محیط اجرا (\lr{Environment Tampering}):}
    گاهی اوقات تحلیل‌گر ناچار است کد بدافزار را در حین اجرا وصله (\lr{Patch}) کند. برای مثال، اگر بدافزار از دستور \lr{RDTSC} برای بررسی زمان اجرا استفاده کند، تحلیل‌گر می‌تواند با تغییر درایورهای سیستم یا تنظیمات ماشین مجازی، کاری کند که این دستور همواره مقداری ثابت یا منطقی را برگرداند، یا به سادگی دستور شرطی که بعد از بررسی زمان قرار دارد را در حافظه به یک دستور پرش بی‌قید و شرط (\lr{JMP}) تغییر دهد تا بررسی امنیتی دور زده شود. \cite{sikorski2012practical}
\end{enumerate}
